# 树的进阶
## 平衡树
在使用二叉树的过程中我们可以发现，如果我们在插入数据的时候是按照逆序的方式插入(即从大到小的方式)，
那么构造出来的树就会变得很糟糕(直接就是形成一个链表了)，这样的结构，如果我们要使用它来查看较小的
元素效率就会变得很低。

## 2-3 查找树
为了确保查找树的平衡性，我们需要一些灵活性，因此在这里我们允许树中的一个结点保存多个键，确切的说，我们将
一颗标准的二叉查找树中的结点称为2-结点(含有一个键和两条链)，而现在我们将引入3-结点，它含有两个键和三条链。
2-结点和3-结点中的每一条链都对应着其中保存的键所分割产生的一个区间.

* 二三查找树的定义
一颗2-3查找树要么为空，要么满足下面的两个要求：
    1. 2-结点:
        含有一个键(极其对应的值)和两条链，做链接指向2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点。
    2. 3-结点:
        含有两个键(极其对应的值)和三条链，左连接指向的2-3树中的键都小于该结点，中连接指向的2-3树中的键都位于该结点的
        两个键之间，右链接指向的2-3    树中的键都大于该结点。
        
        
        
        
 ### 查找
将二叉查找树的查找算法一般化我们就能够直接得到2-3树的查找算法。要判断一个键是否在树中，我们先将它和
根结点中的键比较。如果它和其中任意一个相等，查找命中；否则我们就根据比较的结果找到指向相应区间的连
接，并在其指向的子树中递归地继续查找。如果这个是空链接，查找未命中。

例如下入的对H进行命中查找.
![2-3 tree search](./files\2-3tree-1.PNG)
![2-3 tree search](./files\2-3tree-2.PNG)
![2-3 tree search](./files\2-3tree-3.PNG)

### 插入
往2-3树中插入元素和往二叉查找树中插入元素一样，首先就是要进行查找，然后将结点上为找到的结点上。2-3树之所以
能够保证在最差的情况下的效率的原因在于其插入之后仍然能够保持平衡态。如果查找后未找到的结点是一个2-结点，那么很容易,
我们只需要将新的元素放到2-结点里面使其变成一个3-结点即可，但是如果找到的结点结束与一个3-结点，那么可能有点麻烦.

如下入要插入K键
![2-3tree-insert-1](./files\2-3tree-insert1.PNG) 

![2-3tree-insert-2](./files\2-3tree-insert2.PNG) 

* 向一颗只含有一个3-结点的树插入新的新键
假设2-3树中只包含一个3-结点，这个结点有两个键，没有空间来插入第三哥键了，最自然的方式是我们假设这个结点能存放
三个元素，暂时使其变成一个4-结点，同事他包含四条连接。然后，我们将这个4-结点的中间元素提升，左办的键继续作为其
左子结点，右边的键继续作为右子结点。插入完成，变为平衡2-3查找树，树的高度从0变为1.

如下图插入S
![2-3search tree-3](./files\2-3tree-insert3.PNG)


### 2-3树的性质
1. 任意空连接到根结点的路长度都是相等
2. 4-结点变成3-结点，树的高度不会发生变化，只是当前系欸但是临时的4-结点，分解根结点时。树搞+1
3. 2-3树与普通二叉查找树最大的区别在于，普通的二叉查找树都是自顶向下生长，而2-3树时自定向上生长。


##  红黑树
红黑树主要时对2-3树进行编码，红黑树背后的基本思想是用标准的二叉查找树(完全右2-结点但构成)和一些额外的信息‘
(替换3-结点)来表示2-3树。我们将书中的链接分为两种类型:
        **红链接:** 将两个2-结点连接起来构成一个3-结点;
        **黑链接:** 2-3树中的普通链接
确切的说，我们将3-结点表示为由一条左斜的红色链接(两个2-结点其中之一事另一个的左子结点)相连的两个2-结点。这种
表示法的优点是，我们无需修改就可以直接使用标准的二叉查找树的get方法。
如下所示:

![红黑树](./files\read-black-tree-1PNG.PNG)

        
* 红黑树的定义
红黑树是含有红黑链接并满足下列条件的二叉查找树:
    1. 红链接均为左链接
    2. 没有任何一个结点同事和两条红链接项链
    3. 该树是完美黑色平衡的，即任意空链接到根节点的路径上的黑链接数量相同。
    
### 平衡化
在对红黑树进行一滴血二增删该操作后，很有可能会出现红色的有链接或者两条连续红色的链接，而这些都不满足红黑树的定义
所以我们需要对这些情况通过旋转进行修复，让红黑树保持平衡.

* 左旋
当某个结点的左子结点为黑色，右子结点为红色，此时需要左旋。
前提:当前结点为h，它的右子结点为x。
**左旋过程:**
 1. 让x的左子结点便成为h的右子结点：h.left = x.left;
 2. 让h成为x的左子结点:x.left = h;
 3. 让h的color属性变为x的color属性值:x.color=h.color;
 4. 让h的color属性变为RED:h.color = true；
 
![红黑树左旋](./files\read-black-tree-2.PNG)
 
* 右旋
当某个结点的左子结点是红色，且左子系欸但的左子结点也是红色，需要右旋
**前提:** 当前结点为h，它的左子结点为x；
**右旋的过程:**
    1. 让x的右子结点成为h的左子结点:h.left = x.right;
    2. 让h成为x的右子结点:x.right=h;
    3. 让x的便成为h的color属性:x.color=h.color;
    4. 让h变为RED;
![红黑树右旋](./files\read-black-tree-3.PNG) 





























 
 
 
       


