# 数据结构和算法


## 冒泡排序
[示例文件](./src\main\java\com\itdom\sort\bubble\Bubble.java)
```text
原理:
1. 冒泡排序的原理是，将数组内的元素进行两两排序，如果前一个元素的大小大于后一个元素大小，那么就需要进行元素交换
否则不做变换
2. 比较的元素从第一对元素开始到最后一对元素结束,最终最后的位置的元素值是最大的.
算法复杂度分析：
冒泡排序的时间复杂度分析 冒泡排序使用了双层for循环，其中内层循环的循环体是真正完成排序的代码，所以，
我们分析冒泡排序的时间复杂度，主要分析一下内层循环体的执行次数即可。
在最坏情况下，也就是假如要排序的元素为{6,5,4,3,2,1}逆序，那么：
元素比较的次数为：
(N-1)+(N-2)+(N-3)....+1=((N-1)+1)*(N-1)/2=N^2/2-N/2
元素交换的次数:    
(N-1)+(N-2)+(N-3)....+1=((N-1)+1)*(N-1)/2=N^2/2-N/2
总交换次数:
N^2-N
时间复杂度:O(N^2)
```
## 选择排序
[示例文件](./src\main\java\com\itdom\sort\bubble\Bubble.java)
```text
原理：
每一次遍历的过程中，都假定第一个元素索引出的元素是最小值，其他索引处的值一次进行比较，如果当前索引处的
值大于其他某个索引处的值，则假定其他某个索引处的值未最小值，最后可以周到最小值所在的索引
2. 交换第一个索引处和最小值所在的索引处的值即可.

时间复杂度分析:
比较次数：
(N-1)+(N-2)+(N-3)+...+2+1=((N-1)+1)*(N-1)/2    
交换次数：
N-1
根据大O推导法则，最终的时间复杂度是O(N^2)

```
## 插入排序
[示例文件](./src\main\java\com\itdom\sort\insert\Insert.java)
```text
原理：
1. 把所有的元素分为两组，已经排序的和未排序的。
2. 找到未排序的组中的第一个元素，想已经排序的组进行插入
3. 倒序遍历已经排序的元素，一次和待插入的元素进行比较，之傲找到一个元素小于待插入的元素，那么
待插入元素放到这个位置，其他的元素向后移动一位.
时间复杂度分析
比较的次数
(N-1)+(N-2)+...+1=((N-1)+1)*(N-1)/2
交换的次数
(N-1)+(N-2)+(N-3)+...+2+1=((N-1)+1)*(N-1)/2
根据大O推导法则，可以推导出时间复杂度为O(N^2)
```


## 高级排序之希尔排序
[示例代码](./src\main\java\com\itdom\sort\shell\Shell.java)
```text
实现的原理:
1. 指定一个增长量h，按照增长量做为数据分组的依据。
2. 对每个分好的组进行插入排序
3. 减少增长量，减小为1，重复上述2操作。
时间复杂度分析:此处无法进行分析，只能和插入排序进行比较,执行时间明显小于插入排序

```

## 高级排序之归并排序
[实例文件](./src\main\java\com\itdom\sort\merge\Merge.java)
```text
归并排序是建立在操作上的一种有效的排序算法，改算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，
得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并
实现的原理：
1. 尽可能的将一组数据拆分成两个元素相等的子组，并对每个子组继续拆分，知道拆分后的每个子组的元素个数是1为止
2. 将相邻的两个子组进行合并成一个游学的大组
3.不断的重复步骤2，知道最终只有一个组为止。

时间复杂度:
用树状图来描述归并排序，如果一个数组有8个元素，那么将每次除以2找最小的子数组，共拆分log8次，也就是3次
那么这棵树就有3层，由顶向下第k层由2^k个子数组，每个数组的长度为2^(3-k)，归并最多需要2^(3-k)次比较。
因此每层的比较次数为2^k*2^(3-k)=2^3

将元素设置为n，那么使用归并排序拆分的次数为log2(n)，所以共有log2(n)层，那么使用log2(n)替换上面的3*2^3
中的这个层数，最终得出的归并的时间复杂度为log2(n)*2^log2(n)=k=log2(n)*n,根据大O推导法则，忽略底数，最终
归并排序的时间复杂度为O(nlog2(n))
```
## 高级排序之快速排序
[示例文件](./src\main\java\com\itdom\sort\quick\Quick.java)

```text
排序的原理：
1. 首先设定一个分解值，通过该分解之将数组分成左右两个部分；
2. 将大于或者等于分界值的据放到分界值的右边，小于分界值的数据放到数组的左边。此时左边部分中各元素都大于等于分界值，而右边部分的各个元素都大于分界值
3. 然后，左边和右边的额数据可以独立排序。对左侧的数组数据又可以取一个分界值，将该部分数据分成左右两个部分，同样在左侧方式较小的值，右边部分放置较大
的值。右侧的数组数组也可以做类似的处理
4. 重复上述过程，可以看出，这是一个递归的定义。通过递归将左侧部分排好序列之后，在递归排好哟i测的部分的数据的顺序，当左右两个部分的数据也被排完后，整个
数组的排序也就完成了。

快速排序事件复杂度分析
快速排序的一次切分从两头开始交替搜索，知道left和right重合，一次切分算法的事件复杂度O（n）,d但是整个快速排序的事件复杂度和切分的次数相关
我们可以把数组的切分看作是一棵树，那么他的最有的情况就是二叉树的分组次数，共切分了logn,所以，最优的情况下快速排序的时间复杂度为O(nlogn);
最坏的情况:每次切分选择的基准数字都是当前序列中最大数或者最小数.这使得每次切分都会有一个子组，那么总共就得切分n次，所以，最欢得情况下，快
速排序得时间复杂读为O(n^2);
平均情况:每次切分的基础数字不是最大值和最小是，也不是中值，这种情况我们的也可以使用数学归纳发证明，快速排序的时间复杂度为O(nlogn)。




```
























