# 数据结构和算法


## 冒泡排序
[示例文件](./src\main\java\com\itdom\sort\bubble\Bubble.java)
```text
原理:
1. 冒泡排序的原理是，将数组内的元素进行两两排序，如果前一个元素的大小大于后一个元素大小，那么就需要进行元素交换
否则不做变换
2. 比较的元素从第一对元素开始到最后一对元素结束,最终最后的位置的元素值是最大的.
算法复杂度分析：
冒泡排序的时间复杂度分析 冒泡排序使用了双层for循环，其中内层循环的循环体是真正完成排序的代码，所以，
我们分析冒泡排序的时间复杂度，主要分析一下内层循环体的执行次数即可。
在最坏情况下，也就是假如要排序的元素为{6,5,4,3,2,1}逆序，那么：
元素比较的次数为：
(N-1)+(N-2)+(N-3)....+1=((N-1)+1)*(N-1)/2=N^2/2-N/2
元素交换的次数:    
(N-1)+(N-2)+(N-3)....+1=((N-1)+1)*(N-1)/2=N^2/2-N/2
总交换次数:
N^2-N
时间复杂度:O(N^2)
```
## 选择排序
[示例文件](./src\main\java\com\itdom\sort\bubble\Bubble.java)
```text
原理：
每一次遍历的过程中，都假定第一个元素索引出的元素是最小值，其他索引处的值一次进行比较，如果当前索引处的
值大于其他某个索引处的值，则假定其他某个索引处的值未最小值，最后可以周到最小值所在的索引
2. 交换第一个索引处和最小值所在的索引处的值即可.

时间复杂度分析:
比较次数：
(N-1)+(N-2)+(N-3)+...+2+1=((N-1)+1)*(N-1)/2    
交换次数：
N-1
根据大O推导法则，最终的时间复杂度是O(N^2)

```
## 插入排序
[示例文件](./src\main\java\com\itdom\sort\insert\Insert.java)
```text
原理：
1. 把所有的元素分为两组，已经排序的和未排序的。
2. 找到未排序的组中的第一个元素，想已经排序的组进行插入
3. 倒序遍历已经排序的元素，一次和待插入的元素进行比较，之傲找到一个元素小于待插入的元素，那么
待插入元素放到这个位置，其他的元素向后移动一位.
时间复杂度分析
比较的次数
(N-1)+(N-2)+...+1=((N-1)+1)*(N-1)/2
交换的次数
(N-1)+(N-2)+(N-3)+...+2+1=((N-1)+1)*(N-1)/2
根据大O推导法则，可以推导出时间复杂度为O(N^2)







```


## 高级排序之希尔排序



























