[上一节(堆)](./HEAD.MD)
# 优先队列
```text
队列是一种先进先出FIFO的数据结构,元素都是从队尾加入，从对头弹出的。但是，在某些特殊的情况下，我们需要找到最大值和最小值，此时
如果是普通的队列 ，需要从头尾的遍历去获取最大值或者最小值，但是，这种方式的效率并不高，我们可以使用一种特殊的队列来完成这种需求-优先队列
优先队列按照其作用的不同，可以分为一下集中
1.最大优先队列:
  可以获取并删除队列中最大的值
2. 最小优先队列
  可以获取并删除队列中最小的值。 


```
## 最大优先队列
```text
在使用堆的时候我们可以知道，一个结点是要比它的两个子结点要大的，在做最大优先队列的时候，每次我们只要获取到根结点就是我们的最大的系欸但，也就是
队列内最大的结点 ,但是我们不能直接删除该结点，需要将最后一个结点和根结点进行一个交换，交换后，最大的结点就放到了数组的最后，此时，将最后一个置
空即可完成堆元素的删除，同事，队列内元素个数变化使用N记录。但是，此时的队列因为交换元素，也造成这颗树不符合堆的规则，此时，需要堆根元素进行1-N的
范围的元素下沉操作，使得这棵树符合堆的规则. 
```
[代码实现](./src\main\java\com\itdom\priorityqueue\MaxPriorityQueue.java)


## 最小优先队列
```text
我们前面学习堆的时候，堆中存放数据元素的数组要满足都满足如下特性：
1.最大的元素放在数组的索引1处。
2.每个结点的数据总是大于等于它的两个子结点的数据。

其实我们之前实现的堆可以把它叫做最大堆，我们可以用相反的思想实现最小堆，让堆中存放数据元素的数组满足
如下特性：
1.最小的元素放在数组的索引1处。
2.每个结点的数据总是小于等于它的两个子结点的数据。
```
[最小优先队列代码](./src\main\java\com\itdom\priorityqueue\MinPriorityQueue.java)

[下一节](./TREE_ADVANCED.MD)




