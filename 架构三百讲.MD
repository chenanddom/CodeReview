响应式系统：
1. 可响应能力
可响应能力是一个应用程序最重要的功能，在编程的时候，我们希望能够有一个高效，统一的格式，包括对错误的处理响应，
这一点在Web开发的过程中很常见

2. 高可用性
服务可能挂掉，无法提供服务。



3. 弹性机制
当需求增长的时候，分配的计算机资源也随之增长，当资源需求减少的时候，多分配的资源也随之回收，避免浪费

4. 消息驱动
系统之间使用异步消息通信，做到各个服务之间隔离和松耦合，可以轻松，灵活的扩展和维护系统。

5. 可扩展性机制file:/E:/book/practice/target/classes/com/itdom/HelloWorld.class
可以根据需求进行扩展，而不需要过多的修改什么东西

响应式开发的好处
1. 提高了程序的性能
2. 在多核机器上，提高了计算机资源的利用率。
3. 为异步编程提供了可维护的方案。
4. 提供了被压机制，也就是对计算机资源提供了过载保护的功能



双亲委派机制是什么.md
如何解决线上gc频繁的问题.md
--------------------------------------------------------------------------------------------------
MySQL索引选择行陷阱
就是因为使用了模糊查询之类的，如果查询的字段的区别行不到，重复率高达25以上，那么mysql的sql优化器
可能会出现全文索引的情况。
解决方案：
强制使用索引(有时会有奇效，以实际运行的效果为准)
explain select * from question force index(col) where col='A'

增加缓存，提高全表扫描的速度(需要很大的投入)
	innodb_buffer_pool_size=16G
	innodb_buffer_pool_instance=2
--------------------------------------------------------------------------------------------------
MQ消息中间件实现可靠行投递
发送阶段，遇到高延迟，Producer会多次重发消息，知道Broker ack却恶人，过程中Broker会字段去重 ,超时Producer
产生异常，应用对异常进行 捕获提示

存储阶段，Broker先刷盘在ack确认，即便ack失败消息不回丢失，多次重试直到Producer接收，会导致消息积压。

消费阶段，Broker向Consumer发数据，一段实践为接收，自动重发，直到Consumer Ack确认，Consumer注意幂等处理。	
	
	丢失数据的几个操作
	1. 异步刷盘(NSYNC_FLUSH),改成同步刷盘
	2. 存储介质损坏，建议才有RAID10或者分布式存储
	3. 不要启动自动ACK，RabbitMQ存在此问题
	4.避开都市区传说的ActiveMQ
	
--------------------------------------------------------------------------------------------------
为什么使用代理主键而不使用业务主键
    1. 业务主键浪费空间
    2. 业务主键五顺序，可能造成写如舒徐要更长的实践组织索引
    3. 如果在分库分表的时候，如果使用业务主键是字符串，无法直接进行取模运算，需要先转换成数字才能进行运算
--------------------------------------------------------------------------------------------------
JVM选项规则
* java -version标准选项，任何版本的JVM/任何平台都可以使用
* java -Xms10 非标准选项，部分版本标识
* java -XX:+PrintGCDetail 不稳定参数，不同的JVM有差异，随时可能会被移除
	* PS：+代表开启/-代表关闭
	
* 1.8+优先使用G1垃圾收集器，摆脱各种选项的烦恼
		java -jar -XX:+UseG1GC -Xms2G -Xmx2g -Xss256k -XX:MaxGPauseMillis=300 -Xloggc:/logs/gc.log -XX:+PrintGCTimeStamps -XX:PrintGCDetails test.jar
* -Xms与-Xmx设置相同，减少 内存交换
* 评估Xmx方法:第一次其实设置大一点，跟踪监控日志没调整为堆值*2~3即可
* 最多300好眠STW实践，200~500区间，增大可以减少GC次数，提高吞吐量
* -Xss126k/256k虚拟机栈空间一般128k就够用了，超过256考虑优化，不建议超过256k 
* G1一般不设置新生代的大小，G1新生代就是动态调整的	

-------------------------------------------------------------------------------------------------------
OOM的解决
先使用java的命令dump所有的对内存映射文件xx/hprof
将hprof文件到如visualVM 根据显示的概要情况可以找到未释放的对象
将可能存在未释放的对象进行GCROOT查看，就可以找到引用对象的地方。
然后根据引用对象的地方进行排查和分析，最后找到问题的根源。

-------------------------------------------------------------------------------------------------------
rabbitmq的六种模式
1. simple简单不是，一个生产者一个消费者
2. worker queue工作队列模式，一个生成者多个消费者，可以实现负载均衡
3. publish/subscribe 发布订阅模式，引入了交换机的角色，队列通过绑定交换机实现绑定具体类型的消息
4. routingkey 路由键模式也叫direct模式
5. topic模式，就是提高了路由键的模糊匹配的规则，方便操作
6. rpc模式，可以实现mq的同步调用，但是一般不使用。
-------------------------------------------------------------------------------------------------------
处理消息积压的问题
1. 开启更多的消费者示例，实现消费
2. 使用死信队列将把未能及时处理的消息延后消费

-------------------------------------------------------------------------------------------------------
Kafka队列为什么这么快

1. 磁盘顺序读写
2.  页缓存
3. 零拷贝
4. 批量操作

--------------------------------------------------------------------------------------------------------
CPU、内存，硬盘三大件、Mysql服务器的选择。
*　CPU
	* ６４位的CPU一定要工作在６４位系统下
	* 对于并发比较高的场景CPU的数量比频率更加重要（选择多核，频率相对低的的ｃｐｕ）
	* 对于CPU密集型的场景和复杂的SQL则频率越高越好

* 内存
	* 理想的选择是服务器内存大于数据总量
	* 内存频率越高处理熟读越快
	* 内存总量小要合理组织热点数据，保证内存覆盖
	* 内存堆写操作也有重要的性能影响



----------------------------------------------------------------------------------------------
动态通知的用push还是pull更合适？

push存在写扩散的问题，如果有大量的粉丝，就需要同一时间向消息队列写入大量的数据，瞬间写IO飙升。
* 写扩散
	* 设置上限，微信好友5000个
	* 限流策略，X分钟内完成消息发布
	* 优化存储策略，才有NOSQL或者大数据方案
	
pull模式存在同一时间大量的查询拉去数的情况。
* 度扩散
	* MQ削峰填谷，超长对抗i额直接拒绝
	* 增加轮询时间， 减少请求次数
	* 服务端增加缓存优化查询效率
	* 增加验证码，分散时间，减少机器人刷票
	

---------------------------------------------------------------------------------------------------
缓存一致性如何保障？先写库还是先写缓存？聊聊Cache Aside Pattern与延迟双删

更新缓，如果采用更新缓存的方式，会出现数据不一致的情况，如下图所示
![更新缓存出现的数据不一致的情况](https://app.diagrams.net/#Hchenanddom%2FCharts%2Fmain%2Frepo%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98.drawio)






























