# 垃圾回收算法

## 判断对象存活一般有两种方式：引用计数算法和可达性分析算法。

### 引用计数法
```text
引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。

对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。

优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。

缺点：它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。

每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。 引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。
```
例子:
[RefCountGC.java](./src/main/java/com/itdom/jvm/chapter15/RefCountGC.java)
执行上面的代码得到如下的运行结果：
* 没有运行System.gc();
```shell script
Heap
 PSYoungGen      total 76288K, used 16794K [0x000000076b380000, 0x0000000770880000, 0x00000007c0000000)
  eden space 65536K, 25% used [0x000000076b380000,0x000000076c3e6838,0x000000076f380000)
  from space 10752K, 0% used [0x000000076fe00000,0x000000076fe00000,0x0000000770880000)
  to   space 10752K, 0% used [0x000000076f380000,0x000000076f380000,0x000000076fe00000)
 ParOldGen       total 175104K, used 0K [0x00000006c1a00000, 0x00000006cc500000, 0x000000076b380000)
  object space 175104K, 0% used [0x00000006c1a00000,0x00000006c1a00000,0x00000006cc500000)
 Metaspace       used 3297K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 359K, capacity 388K, committed 512K, reserved 1048576K
```
*　运行System.gc
```shell script
[GC (System.gc()) [PSYoungGen: 15482K->744K(76288K)] 15482K->752K(251392K), 0.0009496 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[Full GC (System.gc()) [PSYoungGen: 744K->0K(76288K)] [ParOldGen: 8K->616K(175104K)] 752K->616K(251392K), [Metaspace: 3299K->3299K(1056768K)], 0.0038904 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
Heap
 PSYoungGen      total 76288K, used 1966K [0x000000076b380000, 0x0000000770880000, 0x00000007c0000000)
  eden space 65536K, 3% used [0x000000076b380000,0x000000076b56b9e0,0x000000076f380000)
  from space 10752K, 0% used [0x000000076f380000,0x000000076f380000,0x000000076fe00000)
  to   space 10752K, 0% used [0x000000076fe00000,0x000000076fe00000,0x0000000770880000)
 ParOldGen       total 175104K, used 616K [0x00000006c1a00000, 0x00000006cc500000, 0x000000076b380000)
  object space 175104K, 0% used [0x00000006c1a00000,0x00000006c1a9a190,0x00000006cc500000)
 Metaspace       used 3311K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 360K, capacity 388K, committed 512K, reserved 1048576K
```
通过上面的执行结果我们可以知道，JVM并没有使用引用计数算法，否则事不可能执行GC成功的，因此通过反推可以知道JVM并没有使用引用计数算法来作为垃圾回收算法


### 可达性分析(或者根搜索算法、追踪性垃圾收集)
* 相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行搞笑的特点更重要的事该算法可以有
效的解决引用计数算法中循环引用的问题，防止内存泄露的问题的发生
* 相较于引用 计数算法，这里的可达性分析就是Java,C#选择的。这种类型的垃圾收集算法通常叫做追踪性垃圾收集(Tracing Garbage Collection).

* 所谓"GC Roots"根集合就是一组必须活跃的引用
    * 可达性分析算法事以根对象集合(GC Roots)为起始点，按照从上至下的方式搜索被根对象集合所引用的目标对下昂是否可达。
    
    * 使用可能性分析算法之后，内存中的存辉对象都会被根对象集合直接或者间接的连着，搜索所走过的路径成为引用链(Reference Chain)
    
    * 如果目标对象没有任何引用相链接，则是不可达的，就以为这该对象已经死亡，可以标记为垃圾对象。
    
    * 可达性分析算法中，只有能够被根对象集合直接或者间接链接的对象才是存活对象。
    

* Java语言中，GC Roots包括以下的几类元素:
    * 虚拟机栈中引用的对象
        * 比如各个线程被调用的方法使用的参数，局部变量等。
    * 本地方法内JNI(通常说的本地方法)引用的对象
    * 方法区中类静态属性引用的对象
        * 比如Java类的引用类型静态变量.
    * 方法区中常量引用的对象
        * 比如字符串常量池(String Table)里面的引用
    * 所有被同步锁synchronized持有的对象
    * Java虚拟机内部的引用
        * 基本数据类型对应的Class对象，一些常驻的异常对象(比如NullPointerException,OutOfMemoryError)，系统类加载其
    * 反映Java虚拟机内部情况的JMXBean,JVMTI中注册的回调，本地代码缓存等.
    
    
## 对象的finalization机制
* Java语言提供了而对象终止(finalization)机制来允许开发人员提供对象金小慧之前的自定义处理逻辑
* 当垃圾回收器发现没有引用指向一个对象，即:垃圾回收此对象之前，总会先调用这个对象的finalize()方法
* finalize()允许在子类中被重写，用于在对象被回收时进行资源的释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件，套接字和数据库链接等。
*　对象的finalize()方法不需要我们主动去调用 ，而实有垃圾回收机制去自动的调用，理由如下：
    * finalize()时可能会导致对象复活
    * finalize()方法的执行是没有保障的，需要GC线程来决定，在极端的情况下，若不发生GC，则finalize()就不会得到执行的机会。
    * 一个糟糕的fianlize()会严重的影响GC的性能。
    
* 由于finalize()方法的存在，虚拟机中的对象一般处于三种可能的状态
    *　如果一个对象从根节点不可达时，说明已经不再使用了。一般来说，此对象需要被回收，但是不是"非死不可"的，这个时候相当于处于"死缓状态"。一个在无法触及的对象可能在某个条件下"复活"自己，那么此时回收就是不合理的，为此，定义虚拟机中的对象可能处于三种状态。
        * 可触及的：从根节点开始，可以到达这个对象
        * 可复活的：对象所有引用都被释放，但是这个对象可以在finalize()方法执行的时候复活自己
        * 不可触及的：对象在finalize()方法执行之后没有复活，那么这个对象将不可触及，此时这个对象就不会再被复活了，因为finalize()方法就会被执行一次

    
    
    
    
### 增量收集算法


### 分区算法
主要时G1收集器在使用    
    
        


