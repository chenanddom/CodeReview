# 虚拟机栈
```text
为了涉及跨平台，JAVA的指令集都是根据栈来设计实现的。不同的CPU架构不同。所以不能设计为基于寄存器的。
基于栈的架构的优点：跨平台，指令集小，编译实现起来容易，缺点是性能下降，实现同样的过年需要更多的指令。
```

* 问题：
  * 有不少Java开发人员一提到Java内存结构，就会非常粗粒度地将JVM中的内存区理解为仅有Java堆（heap）和Java栈（stack）？为什么？
    ```text
    受到C/C++的影响，这两种高级语言是将内存管理分为堆和栈的，同时也体现出了堆区和栈区在VM内存管理的重要性。首先栈是运行时的单位，而堆是存储的单位
    栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。 堆解决的是数据存储的问题，即数据怎么放，放哪里
    ```
  * Java虚拟机栈是什么？
    ```text
    Java虚拟机栈也叫Java栈。每个线程创建的时候都会创建一个虚拟机栈，其内部保存了一个个栈帧，对应着一次次的Java方法调用。是线程私有的，生命周期和
    线程的生命周期是一致的，它的主要作用主要是保存方法的局部变量、部分结果，并参与方法的调用与结果的返回    
    ```
  * 栈的特点
    ```text
    栈是一种快速有效的分配存储的方式，访问速度仅次于寄存器的速度，每次方法的访问伴随着压栈和出栈，程序执行结束就会出栈，栈不存在垃圾手机的问题
    ```


示例：
```java
/**
 * 测试栈设置栈大小-Xss256k
 * 默认情况打印到11421
 * 设置了虚拟机器参数之后打印数据就到了2462，说明虚拟机参数设置生效了.
 */
public class StackTest {
    public static int num=1;
    public static void main(String[] args) {
        System.out.println(num);
        num++;
        main(args);
    }
}
出现错误：
Exception in thread "main" java.lang.StackOverflowError

```

* 关于Slot的理解
  * JVM会为局部变量表中的每个Slot都分配一个访问索引，通过这个索引即可访问到局部变量表中知道的局部变量值。
  * 一个方法被调用的时候，它的的方法参数和方法内定义的局部变量都会被按顺序复制到局部变量表的Slot
  * 如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。(比如：访问long或者double类型变量)
  * 如果当前帧是由构造方法或者示例方法创建的，那么盖对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。


* Slot的重复利用
  * 栈帧中的局部变量表中的槽位是可以重复用的，如果一个局部变量过了其作用域，那么在其作用域之后生命的新的局部变量就很有可能会复用国企局部变量的槽位，达到节约资源的目的。
    ```java
         public class ReuseSlotTest {
         public void method1(){
             int a=0;
             System.out.println(a);
             int b=0;
         }
         public void method2(){
             {
                 int a=0;
                 System.out.println(a);
             }
             int b=0;
         }
               
         public static void main(String[] args) {
             new ReuseSlotTest().method2();
         }
       }

    ```
* 静态变量与局部变量的对比
```markdown
* 参数分配完毕之后，再恩据方法体内定义的变量的顺序和作用域分配
* 我们知道类变量表有两次初始化的机会，一次是在加载后的"准备"阶段，这个阶段主要进行零值的初始化操作，第二个阶段主要是"初始化"阶段，这个阶段才是正在的
  将我们想赋的值进行赋给了变量。
* 和类变量不同的是局部变量一旦定义了就必须人为的去进行初始化操作，否则无法正常的使用。
```
示例
```java
public class LocalVariableTest {
public void localVariableMethod(){
    int a = 0;//此处不赋值无法正常使用。
    System.out.println(a);//此处使用会报错
}
}

```

## 操作数栈
```markdown
* 每一个独立的栈帧中除了包含局部变量意外，还包含了后进先出的操作数栈，或者叫表达式栈。
* 操作数栈，在方法的执行过程中，根据字节码指令，往栈中写入数据或者提取数据，即入栈(push)/出栈(pop)
    * 某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用他们后再把结果压入栈。
    * 比如：执行复制、交换、求和等操作。
```
* 操作数栈
  * 操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储控件
  * 操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈就是空的
  * 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需要的最大深度在编译器就是定义好的，保存在方法的Code属性中，为max_stack的值。
  * 栈中的任何一个元素都是可以任意的Java数据类型
    * 32bit的类型占用一个栈单位深度
    * 64bit的类型栈两个栈单位升读
操作数栈并非以访问索引的方式来进行数据访问的，二十只能通过标准的入栈(push)和出栈(pop)操作来完成一次数据访问。


* 如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。
* 操作数栈中元素的数据类型必须要与字节码治理的序列严格的匹配，这是由编译器在编译期间进行验证，同时在类加载的过程中的
  类检验阶段华发数据分析阶段要再次验证
* Java虚拟机的解释引擎是基于栈执行引擎，其中的栈指的就是操作数栈。
  



## 栈顶缓存技术
```text
JVM是基于栈架构的虚拟机，所使用的架构是零地址指令，更加的紧凑，但是完成一项操作需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令
分派(instruction dispatch)次数和内存读/写次数
由于操作数是存储在内存中的，因此频繁的执行读/写操作会影响执行的速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存(TOP,top-of-stack 
caching)技术，将栈顶全部缓存在物理CPU的寄存器中，以此降低堆内粗的读/写次数，提升执行引擎的执行效率.
```

## 动态链接
```markdown
* 每个栈帧内部都包含一个执行运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能实现动态链接(Dynamic Linking).
  比如:involkedynamic指令
* 在Java源文件被编译到字节码文件中时，所有的变量和方法的引用都是作为符号引用(Symbolic Reference)保存到class文件的常量池里。比如，描述一个方法
   调用了另外的其他方法时，就是通过常量池中只想方法的符号引用老表示的，那么动态链接的作用就是为了将这些符号引用转换为调用的方法的直接引用。
```
![动态链接](./files/动态链接-1.png)


* 常量池的作用？
  * 提供一些符合和常量，便于指令的识别。


### 方法调用
```markdown
对应的方法的绑定机制为：早期绑定(Early Binding)和晚期绑定(Late Binding)。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，
这仅仅发生一次。
* 早期绑定:
  早期绑定是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是
  哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。
* 晚期绑定：
  如果被调用的方法在编译期间无法被确定下来，只能够在程序运行期间根据实际的类型绑定相关的方法，这种绑定方式也称为晚期绑定。
```



























































