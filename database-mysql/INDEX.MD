[上一章(存储引擎)](./STORAGE_ENGINE.MD)
# 索引
MySQL官方索引的定义为:索引(Index)是帮助MySQL高效获取数据的数据结构。
索引的本质:索引是数据结构。你可以简单的理解为"排好序的快速查找数据结构"，满足特定查找算法，这些数据结构以某种方式指向数据，
这样就可以在这些数据结构的基础上实现高级查找算法.

* 索引的优点
    1. 类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的IO成本，这也是创建索引最主
       要的原因。
    2. 通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。   
    3. 在实现数据的参考完整性方面，可以加速表和表之间的连接。换句话说，对于有依赖关系的子表和父表联合查询时，
       可以提高查询速度。
    4. 在使用分组和排序子句进行数据查询时，可以显著减少查询中分组和排序的时 间，降低了CPU的消耗.
    
* 缺点:
    1. 创建索引和维护索引要耗费时间，并且随着数据量的增加，所耗费的时间也会增加。
    2. 索引需要占磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，存储在磁盘上，如果由大佬的索引，索引文件就
    可能比数据文件更快达到最大文件尺寸。
    3. 虽然索引大大提高了拆线呢速度，同时却会降低表更新的速度。当对表中的数据进行增加，删除和修改的时候，索引也要动态的维护，这样就降低了
    数据的维护速度。
  
  
  
## 聚簇索引
* 使用记录主键值的大小记录和页的排序，这包括三个  
    * 页内的记录是按照主键的大小顺序排成一个单向链表。
    * 各个存放用户记录的页页是根据页中用户记录的主键大小顺序排成一个双向链表。
    * 存放目录项记录的页分为不同的层次，在同一层次中的页也是可以根据页中目录项记录的主键的大小顺序排成一个双向链表。

* B+树的叶子结点存储的是完整的用户记录
    * 所谓完整的用户记录，就是指这个记录中存储了所有列的值。

* 聚簇索引的优点：
    * 数据访问更加快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更加快。
    * 聚簇索引对于主键的排序查找和范围查找速度非常快。
    * 按照聚簇索引排列顺序，查找显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据库中读取数据，所以节省了大量的IO操作。
* 聚簇索引缺点
    * 插入速度验证依赖插入的顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于Innodb表，我们一般都会定义
    一个自增长的ID主键。
    * 更新主键的代价很大，因为将会导致背更新的行移动。因此，对于Innodb表，我们一般定义为主键为不可更新。
    * 二级索引访问需要两次索引查找，第一次找到主键，第二次根据主键值找到行数据。
### 二级索引(辅助索引，非聚簇索引)
概念：回表 我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根
据c2列的值查找到完整的用户记录的话，仍然需要到聚簇索引中再查一遍，这个过程称为回表。也就
是根据c2列的值查询一条完整的用户记录需要使用到2 棵B+树！


*　问题：为什么我们还需要一次回表操作呢？直接把完整的用户记录放到叶子节点不OK吗？
因为二级索引(辅助索引，非聚簇索引)，没有存储完整的数据记录，只是将索引键值和主键存储的列存储在结构体内，但是主键索引(聚簇索引)
存储在了索引结构内，只要知道了主键，我们就知道了完整的记录，所以需要到主键索引进行回表查找。


## 联合索引
我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按
照c2和c3列的大小进行排序，这个包含两层含义：
    * 先把各个记录和页按照c2列进行排序。
    * 在记录的c2列相同的情况下，采用c3列进行排序
注意一点，以c2和c3列的大小为排序规则建立的B+树称为联合索引，本质上也是一个二级索引。它的意
思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：    
    *　建立联合索引只会建立如上图一样的1棵B+树。
    * 为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。
    
    
*　B+树至少需要存储两条记录
为了页结构能够更加紧凑，便于数据能够在这样的结构内方便查找，而且不会形成非常多的目录，所以InnoDB的一个数据页至少可以存放两条记录。




## MyISAM中的索引结构
MyISAM存储引擎默认使用的是BTree索引，Memory默认使用的是Hash索引。
MyISAM引擎使用B+Tree作为索引结构，叶子结点的data域存放的是数据记录的地址。
![MyISAM中的索引结构](./files\MyIAM-1.png)

*　MyISAM 与 InnoDB对比

MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。小结两种引擎中索引的区
别：

① 在InnoDB存储引擎中，我们只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录，而在
MyISAM 中却需要进行一次回表操作，意味着MyISAM中建立的索引相当于全部都是二级索引。

② InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是分离的，索引文件仅保存数
据记录的地址。

③ InnoDB的非聚簇索引data域存储相应记录主键的值，而MyISAM索引记录的是地址。换句话说，
InnoDB的所有非聚簇索引都引用主键作为data域。

④ MyISAM的回表操作是十分快速的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通
过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。

⑤ InnoDB要求表必须有主键（ MyISAM可以没有）。如果没有显式指定，则MySQL系统会自动选择一个
可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐
含字段作为主键，这个字段长度为6个字节，类型为长整型



### 索引的代价
索引的使用是可以帮助数据的查询的，但是不能随便乱建索引，它会在空间和时间上有所消耗
* 空间上的代价
每建立一个索引豆芽为它建立一颗B+树，每一颗B+树的每一个结点都是一个数据页，一个页默认是占用16KB的存储空间，一颗很大的B+树
是由许多的数据页组成的，那样需要很大的存储空间。


* 时间上的代价

每次对表中的数据进行增、删、改操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每
层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还
是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序
而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需
要额外的时间进行一些记录移位， 页面分裂、页面回收等操作来维护好节点和记录的排序。如果
我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。



















































    