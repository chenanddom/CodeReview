[上一章(存储引擎)](./STORAGE_ENGINE.MD)
# 索引
MySQL官方索引的定义为:索引(Index)是帮助MySQL高效获取数据的数据结构。
索引的本质:索引是数据结构。你可以简单的理解为"排好序的快速查找数据结构"，满足特定查找算法，这些数据结构以某种方式指向数据，
这样就可以在这些数据结构的基础上实现高级查找算法.

* 索引的优点
    1. 类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的IO成本，这也是创建索引最主
       要的原因。
    2. 通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。   
    3. 在实现数据的参考完整性方面，可以加速表和表之间的连接。换句话说，对于有依赖关系的子表和父表联合查询时，
       可以提高查询速度。
    4. 在使用分组和排序子句进行数据查询时，可以显著减少查询中分组和排序的时 间，降低了CPU的消耗.
    
* 缺点:
    1. 创建索引和维护索引要耗费时间，并且随着数据量的增加，所耗费的时间也会增加。
    2. 索引需要占磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，存储在磁盘上，如果由大佬的索引，索引文件就
    可能比数据文件更快达到最大文件尺寸。
    3. 虽然索引大大提高了拆线呢速度，同时却会降低表更新的速度。当对表中的数据进行增加，删除和修改的时候，索引也要动态的维护，这样就降低了
    数据的维护速度。
  
  
  
## 聚簇索引
* 使用记录主键值的大小记录和页的排序，这包括三个  
    * 页内的记录是按照主键的大小顺序排成一个单向链表。
    * 各个存放用户记录的页页是根据页中用户记录的主键大小顺序排成一个双向链表。
    * 存放目录项记录的页分为不同的层次，在同一层次中的页也是可以根据页中目录项记录的主键的大小顺序排成一个双向链表。

* B+树的叶子结点存储的是完整的用户记录
    * 所谓完整的用户记录，就是指这个记录中存储了所有列的值。

* 聚簇索引的优点：
    * 数据访问更加快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更加快。
    * 聚簇索引对于主键的排序查找和范围查找速度非常快。
    * 按照聚簇索引排列顺序，查找显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据库中读取数据，所以节省了大量的IO操作。
* 聚簇索引缺点
    * 插入速度验证依赖插入的顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于Innodb表，我们一般都会定义
    一个自增长的ID主键。
    * 更新主键的代价很大，因为将会导致背更新的行移动。因此，对于Innodb表，我们一般定义为主键为不可更新。
    * 二级索引访问需要两次索引查找，第一次找到主键，第二次根据主键值找到行数据。
### 二级索引(辅助索引，非聚簇索引)
概念：回表 我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根
据c2列的值查找到完整的用户记录的话，仍然需要到聚簇索引中再查一遍，这个过程称为回表。也就
是根据c2列的值查询一条完整的用户记录需要使用到2 棵B+树！


*　问题：为什么我们还需要一次回表操作呢？直接把完整的用户记录放到叶子节点不OK吗？
因为二级索引(辅助索引，非聚簇索引)，没有存储完整的数据记录，只是将索引键值和主键存储的列存储在结构体内，但是主键索引(聚簇索引)
存储在了索引结构内，只要知道了主键，我们就知道了完整的记录，所以需要到主键索引进行回表查找。


## 联合索引
我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按
照c2和c3列的大小进行排序，这个包含两层含义：
    * 先把各个记录和页按照c2列进行排序。
    * 在记录的c2列相同的情况下，采用c3列进行排序
注意一点，以c2和c3列的大小为排序规则建立的B+树称为联合索引，本质上也是一个二级索引。它的意
思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：    
    *　建立联合索引只会建立如上图一样的1棵B+树。
    * 为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。
    
    
*　B+树至少需要存储两条记录
为了页结构能够更加紧凑，便于数据能够在这样的结构内方便查找，而且不会形成非常多的目录，所以InnoDB的一个数据页至少可以存放两条记录。




## MyISAM中的索引结构
MyISAM存储引擎默认使用的是BTree索引，Memory默认使用的是Hash索引。
MyISAM引擎使用B+Tree作为索引结构，叶子结点的data域存放的是数据记录的地址。
![MyISAM中的索引结构](./files\MyIAM-1.png)

*　MyISAM 与 InnoDB对比

MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。小结两种引擎中索引的区
别：

① 在InnoDB存储引擎中，我们只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录，而在
MyISAM 中却需要进行一次回表操作，意味着MyISAM中建立的索引相当于全部都是二级索引。

② InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是分离的，索引文件仅保存数
据记录的地址。

③ InnoDB的非聚簇索引data域存储相应记录主键的值，而MyISAM索引记录的是地址。换句话说，
InnoDB的所有非聚簇索引都引用主键作为data域。

④ MyISAM的回表操作是十分快速的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通
过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。

⑤ InnoDB要求表必须有主键（ MyISAM可以没有）。如果没有显式指定，则MySQL系统会自动选择一个
可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐
含字段作为主键，这个字段长度为6个字节，类型为长整型



### 索引的代价
索引的使用是可以帮助数据的查询的，但是不能随便乱建索引，它会在空间和时间上有所消耗
* 空间上的代价
每建立一个索引豆芽为它建立一颗B+树，每一颗B+树的每一个结点都是一个数据页，一个页默认是占用16KB的存储空间，一颗很大的B+树
是由许多的数据页组成的，那样需要很大的存储空间。


* 时间上的代价

每次对表中的数据进行增、删、改操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每
层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还
是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序
而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需
要额外的时间进行一些记录移位， 页面分裂、页面回收等操作来维护好节点和记录的排序。如果
我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。




## 问答题


1. 思考题：为了减少IO，索引树会一次性加载吗？
    1. 数据库的索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小也会很大，超过G级别
    2. 当我们利益索引查询的时候，是可能将全部的几个G的索引全部加入内存的，我们能做的只能是:逐一加载每一个磁盘页，
    因为磁盘页对应这索引树的结点。



2. 思考题：B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO
    Innodb存储引擎中页的大小为16kb，一般表的主键类型都是INT(占用4个字节)或者BigINT(占用8个字节)，指针类型也一般为4~8个字节
也就是谁一个页(B+Tree)中的一个结点 中大概存储16KB/(8B+8B)=1K个键值(因为是估值)，为了方便技术按，这里的K值为10^3，也就是说升读为3的
B+Tree索引可以维护10^3*10^3*10^3-=10亿条记录。
    实际情况中每个系欸但那都可能不能填充慢，因此在数据库中，B+Tree的高度一般都是在2~4层。MySQL的Innodb存储引擎在涉及时是将根结点常驻在
内存的，也就是说查找某一个键值的行记录时最多只需要1~3次磁盘的IO操作。
   
3. 思考题：为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？
    1. B+树的磁盘读写代价更低
      B+树的内部结点并没有指向关键字具体信息的指针。因此其内部的结点相对B树更加小。如果要把所有同亿内部结点的关键字存放在同一盘块中
      那么盘块所能容纳的关键字数量也就乐队。一次性读入内存中的需要查找的关键字也就乐队，相对来水IO读写次数也就降低了。
    2. B+树的查询效率更加稳定
        由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须要走一条从根结点到叶子结点的路
        所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。    
    


4. 思考题：Hash 索引与 B+ 树索引的区别
    1. Hash索引不能进行范围查找，而B+树时可以做到的。因为Hash索引指向的数据时无需的，而B+树 的叶子系欸但时各个有序的链表。
    2. Hash索引不支持联合索引的最左原则(即联合索引的部分索引无法使用)，而B+树时可以的。对于联合索引来说，Hash索引在计算Hash
        值的。因此如果用到联合索引的一个或者几个索引的时候，联合索引无法被利用。
    3. Hash索引不支持ORDER BY 排序，因为Hash索引指向的数据时无需的，因此无法起到排序优化的作用，而B+树索引数据时有序的，可以起到对该
       字段的ORDER BY排序优化的作用。同理，我们也无法用Hash索引今昔模糊查询，而B+树使用LIKE的模糊查询的时候，Like后面的模糊匹配就可以
        实现     

5. 思考题：Hash 索引与 B+ 树索引是在建索引的时候手动指定的吗？
![mysql存储引擎对hash索引的支持](./files\索引的数据结构-1.PNG)
补充：NDB也支持Hash索引
Innodb支持自适应的hash索引，可以提高查询频繁查找的数据。它的结构如下所示:
![Innodb支持自适应的hash索引    ](./files\索引的数据结构-2.png)
我们可以通过innodb_adaptive_hash_index 变量来查看是否开启了自适应 Hash，比如：
```sql
mysql> show variables like '%adaptive_hash_index';    
```












































    