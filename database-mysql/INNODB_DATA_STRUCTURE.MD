[上一章(索引)](./INDEX.MD)
#Innodb数据结构

* 磁盘与内存交互基本单位:页
InnoDB将树划分为若干个页，InnoDB中页的大小默认为16KB
以页作为磁盘和内存之间交互的基本单位，页就是一次最少从磁盘读取16kB的内容到内存中，一次最少把内粗中的16KB内容刷新到磁盘中
在数据库中，不论读一行，还是读多行，都是将这些行为所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页(Page)，数据
库I/O操作的最小单位是页。一个页中可以存储多个行记录.

页默认的大小是16KB，如下图所示:
![页默认的大小](./files\页默认的大小-1.PNG)

## 页的结构
页不惜在物理内存上是连续的存储空间，只需要通过将双向链表象关联即可，每个数据页中的记录会按照主键值从小到大的顺序组成一个单向链表，每个数据页
都会为存储在它里面的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速的定位到对于的槽，然后再变量该槽对于分组中的
记录即可快速查找到指定的记录。

* 页上层的结构
    在数据库这还存在折区(Extent),段(Segment)和表空间(Tablespace)的概念。行、页、区，段、表空间，它们的关系如下图所示，b
![行、页、区、段、表空间的关系](./files\页的结构-1.png)

区(Extent):是比页大一级的存储结构，在InnoDB存储引擎中，一个区会分配64个连续的页。因为InnoDB中的页大小默认是16KB，所以一个区的大小是64*16=1024KB=1M

段(Segment)由一个或者多个区组成，区在文件系统是一个连续分配的空间(在InnoDB中是连续的64个页)，不过在段中不要求区与区站之间是相邻的。段是数据库中的分配单
位，不同的类型的数据库对象以不同的段形式存在。当我们创建数据库表，索引的时候，就会相应的创建对应的段，比如创建一张表段，创建一个索引是会创建一个索引段。

表空间(Tablespace)是一个逻辑容器，表空间存储的对象是段，子啊一个表空间中可以有一个或者多个段，但是一个段只能术语一个表空间。数据库由一个或者多个表空间组成，
表空间从管理上可以划分为系统表空间，用户表空间，撤销表空间，临时表空间等。

## 页的内部结构
页如果按照类型划分的话，常见的由数据页(保存B+树结点)，系统页，Undo页和事务数据页等.数据页是我们最常使用的页。
数据页的16KB大小的存储空间被划分为七个部分，分别为文件头(File Header),页头(Page Header),最大最小记录(Infimum+supermum)、用户记录(User Records)
空闲空间(Free Space),页目录(Page Directory)和文件尾(File Tailer).

* 页结构的各个组成部分的说明如下:

|名称|占用大小|说明|
| ---- | ---- | ---- |
|File Header |38字节|文件头，描述的信息|
|Page Header |56字节|页头，页的状态信息|
|Infimum+Supermum|26字节|最大和最小记录，这是两个虚拟的行记录|
|User Records|不确定|用户记录，存储行记录内容|
|Free Space|不确定|空闲记录，页中还没有被使用的空间|
|Page Directory|不确定|页目录，存储用户记录的相对位置|
|File Trailer|8字节|文件尾，校验页是否完整|
    
* File Header (文件头)
    1. FIL_PAGE_OFFSET（4字节）
    2. FIL_PAGE_TYPE（2字节）
    3. FIL_PAGE_PREV（4字节）和FIL_PAGE_NEXT（4字节）
    4. FIL_PAGE_SPACE_OR_CHKSUM（4字节）
    5. FIL_PAGE_LSN（8字节）
    
* File Tailer(文件尾)

    1. 前4个字节代表页的校验和，这个部分和FileHeader中的FILE_PAGE_SPACE_OR_CHKSUM相对应
       后4个字节代表页面最后修改时对应的日志序列位置(LSN)这个部分也是为了校验页的完整性的，如果首部和尾部的LSN值校验不成功的话，就说明同步过程出现了问题。
     

* Free Space       
    1. 我们自己存储的记录会按照指定的行格式存储到User Records部分。但是在一开始生成页的时候，其实并没有User Records这个部分，每当我们插入一条记录，
        都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分， 当Free Space部分的空间全部被
        User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了。
    

*　User Records(用户记录)
    1. User Records中的这些记录按照指定的行格式一条一条摆在User Records部分，相互之间形成单链表。
      用户记录里的一条条数据如何记录？
      这里需要讲讲记录行格式的记录头信息。
      
* Infimum + Supremum（最小最大记录）
    1.   InnoDB规定最小记录与最大记录这两条记录的构造十分简单，都是由5个字节大小的记录头信息和8字节大小的一个固定的部分组成的
        
![最小最大记录](./files\最大最小记录-1.png)



* Page Header(页头)



*  Page Directory(页目录)

    1. 在页中，记录是以单向链表的形式进行存储的。单向链表的特点就是插入、删除非常方便 ，但是检索效率不高，最差的情况下需要遍历链表上的
    所有节点才能完成检索。因此在页结构中专门设计了页目录这个模块，专门给记录做一个目录，通过二分查找法的方式进行检索，提升效率。
        1. 将所有的记录分成几个组，这些记录包括最小记录和最大记录，但是不包括标记尾"已删除"的记录
        2. 第一组，也就是最小记录所在的分组只有1个记录
            最后一组，就是最大记录所在的分组，会有1~8条记录;
            其余的组的记录的数量都是在4~8条之间。
            这样最的好处是，除了第一组(最小记录所在的组)以外，其余的组的记录数会尽量平分。
        3. 每一组的的最后一条记录的头信息都会存储该组一共多少条记录，作为n_owned字段。
        4. 页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量页被称作槽(Slot),每个槽相当于指针
        指向了不同组的醉胡一个记录。
     ![页目录](./files\页目录-1.png)   
例子:
现在向page_demo表中添加更多的数据。如下：
INSERT INTO page_demo 
VALUES
(5, 500, 'zhou'), 
(6, 600, 'chen'), 
(7, 700, 'deng'), 
(8, 800, 'yang'), 
(9, 900, 'wang'), 
(10, 1000, 'zhao'), 
(11, 1100, 'qian'), 
(12, 1200, 'feng'), 
(13, 1300, 'tang'), 
(14, 1400, 'ding'), 
(15, 1500, 'jing'), 
(16, 1600, 'quan');         
            
添加了12条记录，现在页里一共有18条记录了（包括最小和最大记录），这些记录被分成了5个组，如图所示：
![页目录](./files\页目录-2.png)
这里只保留了16条记录的记录头信息中的n_owned和next_record属性，省略了各个记录之间的箭头。
现在看怎么从这个页目录中查找记录。因为各个槽代表的记录的主键值都是从小到大排序的，所以我们可以使用二分法来进行快速查找。5个槽的编号分别是：0、1、2、3、4，所以初始情况下最低的槽就是low=0，最高的槽就是high=4。比方说我们想找主键值为6的记录，过程是这样的：
 
1. 计算中间槽的位置：(0+4)/2=2，所以查看槽2对应记录的主键值为8，又因为8 > 6，所以设置high=2，low保持不变。
2. 重新计算中间槽的位置：(0+2)/2=1，所以查看槽1对应的主键值为4，又因为4 < 6，所以设置low=1，high保持不变。
3. 因为high - low的值为1，所以确定主键值为6的记录在槽2对应的组中。此刻我们需要找到槽2中主键值最小的那条记录，然后沿着单向链表遍历槽2中的记录。
但是我们前边又说过，每个槽对应的记录都是该组中主键值最大的记录，这里槽2对应的记录是主键值为8的记录，怎么定位一个组中最小的记录呢？别忘了各个槽都是挨着的，我们可以很轻易的拿到槽1对应的记录（主键值为4），该条记录的下一条记录就是槽2中主键值最小的记录，该记录的主键值为5。所以我们可以从这条主键值为5的记录出发，遍历槽2中的各条记录，直到找到主键值为6的那条记录即可。
由于一个组中包含的记录条数只能是1~8条，所以遍历一个组中的记录的代价是很小的。


* Page Header(页面头)
    1. 为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，
    特意在页中定义了一个叫Page Header的部分，这个部分占用固定的56个字节，专门存储各种状态信息。


## 从数据页的角度看B+树的查询
一颗B+树按照结点类型可以分成两部分:
1. 叶子结点，B+树最底层的结点，结点的高度为0，存储行记录。
2. 非叶子结点，结点的而高度大于0，存储索引的键和页面指针并不存储行记录本身。

* _普通索引和唯一索引在查询效率上有什么不同_
我们创建索引的时候可以是普通索引，页可以是唯一索引，那么这两个索引在查询效率上有什么不同？
唯一索引就是在普通索引上增加了约束性，也就是关键字唯一，找到关键字就可以停止检索。而普通索引可能会存在用户记录中的关键字相同的情况，根据
页结构的原理，当我么不读取一条记录的时候，不是单独的从磁盘这读出去，而实将这个记录所在的页加载到内存中进行读取。InnoDB存储引擎的页大小为
16KB，在一个页中可能存储这上千个记录，因此在普通索引的字段上进行查找也就是在内存中多几次"判断下一条记录"的操作，对于CPU来说，这些操作所
消耗的时间是可以忽略不计的。所以对一个索引字段进行检索，采用普通索引还是唯一索引在检索效率上基本上没有差别.


## InnoDB行格式
MySQL默认的行格式可以使用一下的命令进行查看
![MySQL默认的行格式](./files\行格式-1.PNG)

在创建或者修改表的语句中我们可以手动的指定行格式
CREATE TABLE 表名(列信息)ROW_FORMAT=列格式名称
ALTER TABLE 表名 ROW_FORMAT=行格式名称


### COMPACT
MySQL5.1版本中，默认设置Compact为行格式，一条完整的记录其实可以被分为记录的额外信息和记录的真实信息量部分。
Compact信息主要有以下几个部分组成:
* 变长字段长度列表
    MySQL支持一些变长的数据类型，比如VARCHAR(M)、VARBINARY(M)、TEXT类型，BLOB类型，这些数据类型修饰列称为变长字段，变长字段中存储多少字节
的数据不是固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来。在Compact行格式中，把所有变长字段的真实数据占用的字
节长度都存放在记录的开头部位，从而形成一个变长字段长度列表。

 注意：
 
    这里面存储的变长长度和字段顺序是反过来的。比如两个varchar字段在表结构的顺序是a(10)，b(15)。那么在变长字段长度列表中存储的长度顺序就
    是15，10，是反过来的。
    
举例子：

假如我们往表里面插入了test1(col1 varchar(8),col2 varchar(8),col3 varchar(8))插入了一条记录：

|列名|存储内容|内容长度(十进制)|内容长度(十六进制)|
| ---- | ---- | ---- | ----- |
|col1|'zhangsan'|8|0x08|
|col2|'lisi'|4|0x04|
|col3|'wangwu'|5|0x05|


又因为这些长度值需要按照列的逆序存放，所以最后变长字段长度列表的字节串用十六进制表示的效果就是（各个字节之间实际上没有空格，用空格隔开只是方便理解）：
06 04 08 

把这个字节串组成的变长字段长度列表填入上边的示意图中的效果就是：

|050408|NULL值列表|记录头信息|zhangsan|lisi|...|列n的值|
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |


* NULL值列表
之所以要存储NULL值是因为数据都是需要对齐的，如果没有NULL值的位置，就有可能在拆线呢数据的时候出现混乱。如果使用一个特定的符好放在相应的数据位
表示空置的话，虽然能够达到效果，但是这样很浪费空间，所以直接在行的数据头部开辟一块空间专门用来记录该行数据哪些是非空的数据，哪些是空数据，格式如下:
    1. 二进制位为1时，代表该列的值为NULL。
    2. 二进制位的值位0时，代表该列的值不为NULL。
举例子:
字段 a、b、c，其中a是主键,在某一行中存储的数依次是 a=1、b=null、c=2。那么Compact行格式中的NULL值列表中存储：01。第一个0表示c不为null，
第二个1表示b是null。这里之所以没有a是因为数据库会自动跳过主键，因为主键肯定是非NULL且唯一的，在NULL值列表的数据中就会自动跳过主键

|变长字段长度列表|000| 记录头信息 | 列值a | 列值b |...|列值n的值|
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |

注意，对于明确指定字段为非空就不需要

* 记录头信息（5字节）
记录头信息组要包括了

|名称|大小(单位:bit)|描述|
| ---- | ---- | ---- |
|预留位1|1|没有使用|
|预留位2|1|没有使用|
|delete_mask|1|标记该记录是否被删除|
|min_rec_mask|1|B+树的每层非叶子结点中的最小记录都会添加该标记|
|n_owned|4|表示当前的记录拥有的记录树|
|heap_no|13|表示当前记录在记录堆的位置信息|
|record_type|3|表示当前记录的类型，0表示普通记录，1表示B+树非叶子结点记录，2表示最小记录，3表示最大记录|
|next_record|16|表示下一条记录的相对位置|

![记录头信息](./files\行格式-2.png)
举例子:
插入数据：
INSERT INTO page_demo 
VALUES
(1, 100, 'song'), 
(2, 200, 'tong'), 
(3, 300, 'zhan'), 
(4, 400, 'lisi');
图示如下：
![插入信息](./files\行格式-3.png)


*  记录的真实数据
记录的真实数据除了我们自己定义的列的数据以外，还会有三个隐藏列：

|列名|是否必须|占用空间|描述|
| ---- | ---- | ---- | ----|
|row_id|否|6字节|行ID，唯一表示一条记录|
|transaction_id|是|6字节|事务id|
|roll_pointer|是|7字节|回滚指针|

### Dynamic和Compressed行格式
InnoDB存储引擎可以将一条记录中的某些数据存储在真正的数据页面之外。
 
很多DBA喜欢MySQL数据库提供的VARCHAR(M)类型，认为可以存放65535字节。这是真的吗？如果我们使用 ascii字符集的话，一个字符就代表一个字节，我们看看VARCHAR(65535)是否可用。
CREATE  TABLE  varchar_size_demo(
 c  VARCHAR(65535)
 )  CHARSET=ascii  ROW_FORMAT=Compact;
结果如下：
ERROR 1118 (42000): Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. This includes storage overhead, check the manual. You have  to  change  some  columns  to  TEXT or  BLOBs
 
报错信息表达的意思是：MySQL对一条记录占用的最大存储空间是有限制的，除BLOB或者TEXT类型的列之外， 其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节。
 
这个65535个字节除了列本身的数据之外，还包括一些其他的数据，以Compact行格式为例，比如说我们为了存储一个VARCHAR(M)类型的列，除了真实数据占有空间以外，还需要记录的额外信息。
 
如果该VARCHAR类型的列没有NOT NULL属性，那最多只能存储65532个字节的数据，因为变长字段的长度占用 2个字节，NULL值标识需要占用1个字节

我们可以知道一个页的大小一般是16KB，也就是16384字节，而一个VARCHAR(M)类型的列就最多可以存储65533个字节，这样就可能出现一个页存放不了一条记录，这种现象称为行溢出。 
在Compact和Reduntant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中进行分页存储，然后记录的真实数据处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页。
这称为页的扩展，举例如下：
![行溢出](./files\行格式-4.png)



### Redundant行格式

MySQL 5.0支持Redundant是为了兼容之前版本的页格式。
 
现在我们把表record_test_table的行格式修改为Redundant：
ALTER TABLE record_test_table ROW_FORMAT=Redundant;
Query OK, 0 rows affected (0.05 sec)
Records: 0  Duplicates: 0  Warnings: 0

![Redundant存储格式](./files\行格式-5.png)

注意Compact行格式的开头是变长字段长度列表，而Redundant行格式的开头是字段长度偏移列表，与变长字段长度列表有两处不同：
    1.少了“变长”两个字：Redundant行格式会把该条记录中所有列（包括隐藏列）的长度信息都按照逆序存储到字段长度偏移列表。
    2. 多了“偏移”两个字：这意味着计算列值长度的方式不像Compact行格式那么直观，它是采用两个相邻数值的差值来计算各个列值的长度。

举例：比如第一条记录的字段长度偏移列表就是：
2B 25 1F 1B 13 0C 06
 
因为它是逆序排放的，所以按照列的顺序排列就是：
06 0C 13 17 1A 24 25
按照两个相邻数值的差值来计算各个列值的长度的意思就是：
 
第一列(row_id)的长度就是 0x06个字节，也就是6个字节。
第二列(transaction_id)的长度就是 (0x0C - 0x06)个字节，也就是6个字节。
第三列(roll_pointer)的长度就是 (0x13 - 0x0C)个字节，也就是7个字节。
第四列(col1)的长度就是 (0x1B - 0x13)个字节，也就是8个字节。
第五列(col2)的长度就是 (0x1F - 0x1B)个字节，也就是4个字节。
第六列(col3)的长度就是 (0x25 - 0x1F)个字节，也就是6个字节。
第七列(col4)的长度就是 (0x2B - 0x25)个字节，也就是6个字节。




















