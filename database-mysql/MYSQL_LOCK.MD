[上一章(MySQL事务日志)](./MYSQL_TRANSACTION_LOG.MD)
# MySQL 锁
在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的
资源。为保证数据的一致性，需要对并发操作进行控制，因此产生了锁。同时锁机制也为实现MySQL
的各个隔离级别提供了保证。锁冲突也是影响数据库并发访问性能的一个重要因素。所以锁对数据库而
言显得尤其重要，也更加复杂。

## MySQL并发事务访问相同记录
并发事务访问相同记录的情况大致可以划分为3种：

### 读-读情况
读读情况，即并发事务相继读取相同的记录。读去操作本身不会记录有任何影响，并不会引起数目问题，所以运行着情况发生，

### 写-写情况
写写的情况，即并发事务相继的对相同的记录做出了改动。
在这种情况下会发生脏写的问题，任何一种隔离级别都不允许这种问题的发生。所以多个未提交的事务相继对一条几里路做改动时，需要让它们排队执行，
这个排队的过程其实时通过锁来实现的。这个所谓的锁其实时一个内存中的结构，在事务执行前本来时没有锁的，也就是说一开始时没有锁结构和记录进行关联的。
当一个事务想对这条记录做改动时，首先会看看内存中有没有于这条记录相关联的锁结构，当没有的时候就会在内存中生成一个锁结构与之关联。比如事务T1
要于这条记录做改动，就需要生成一个锁结构与之关联:
![数据库事务](./files\数据库锁-1.PNG)

* 不加锁
    意思就是不需要在内存中生成对应的锁结构，可以直接执行操作。
* 获取锁成功，或者加锁成功
    意思就是在内存中生成了对应的锁结构，而且锁结构的is_waiting 属性为false ，也就是事务
    可以继续执行操作。
* 获取锁失败，或者加锁失败，或者没有获取到锁
    意思就是在内存中生成了对应的锁结构，不过锁结构的is_waiting 属性为true ，也就是事务
    需要等待，不可以继续执行操作。

### 读-写情况
读-写或者写-读，即一个事务进行读取操作，零个进行改动操作。这种情况下可能发生脏读，不可重复读，幻读的问题。
各个数据库厂商对SQL标准的支持都可能不一样。比如MySQL在REPEATABLE READ 隔离级别上就已经
解决了幻读问题。

* 并发问题的解决方案：
    * 读取操作利用多版本控制并发控制(MVCC)，写操作进行加锁。
        普通的的SELECT语句在READ COMMITED和REPEATABLE READ隔离级别下会使用到MVCC读取记录
            1. 在READ COMMITTED隔离级别下，一个事务在执行的过程中每次执行SELECT操作时都会生成一个ReadView,ReadView的存在本身就保
               证了事务不可以读取到未提交的事务所作的更改
            2. 在REPEATABLE READ隔离级别下，一个事务的执行过程中只有第一次执行SELECT 操作才会生成ReadView,之后的SELECT操作都会复用
               这个ReadView，这样就可以避免了不可复用和幻读的问题。
    * 读，写操作都采用枷锁的方式
   
* 小结对比发现：
     * 采用MVCC 方式的话， 读-写操作彼此并不冲突， 性能更高。
     *  采用加锁方式的话， 读-写操作彼此需要排队执行，影响性能。
     
一般情况下我们当然愿意采用MVCC 来解决读-写操作并发执行的问题，但是业务在某些特殊情况
下，要求必须采用加锁的方式执行。下面就讲解下MySQL中不同类别的锁。            