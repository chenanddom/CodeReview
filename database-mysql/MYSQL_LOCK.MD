[上一章(MySQL事务日志)](./MYSQL_TRANSACTION_LOG.MD)
# MySQL 锁
在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的
资源。为保证数据的一致性，需要对并发操作进行控制，因此产生了锁。同时锁机制也为实现MySQL
的各个隔离级别提供了保证。锁冲突也是影响数据库并发访问性能的一个重要因素。所以锁对数据库而
言显得尤其重要，也更加复杂。

## MySQL并发事务访问相同记录
并发事务访问相同记录的情况大致可以划分为3种：

### 读-读情况
读读情况，即并发事务相继读取相同的记录。读去操作本身不会记录有任何影响，并不会引起数目问题，所以运行着情况发生，

### 写-写情况
写写的情况，即并发事务相继的对相同的记录做出了改动。
在这种情况下会发生脏写的问题，任何一种隔离级别都不允许这种问题的发生。所以多个未提交的事务相继对一条几里路做改动时，需要让它们排队执行，
这个排队的过程其实时通过锁来实现的。这个所谓的锁其实时一个内存中的结构，在事务执行前本来时没有锁的，也就是说一开始时没有锁结构和记录进行关联的。
当一个事务想对这条记录做改动时，首先会看看内存中有没有于这条记录相关联的锁结构，当没有的时候就会在内存中生成一个锁结构与之关联。比如事务T1
要于这条记录做改动，就需要生成一个锁结构与之关联:
![数据库事务](./files\数据库锁-1.PNG)

* 不加锁
    意思就是不需要在内存中生成对应的锁结构，可以直接执行操作。
* 获取锁成功，或者加锁成功
    意思就是在内存中生成了对应的锁结构，而且锁结构的is_waiting 属性为false ，也就是事务
    可以继续执行操作。
* 获取锁失败，或者加锁失败，或者没有获取到锁
    意思就是在内存中生成了对应的锁结构，不过锁结构的is_waiting 属性为true ，也就是事务
    需要等待，不可以继续执行操作。

### 读-写情况
读-写或者写-读，即一个事务进行读取操作，零个进行改动操作。这种情况下可能发生脏读，不可重复读，幻读的问题。
各个数据库厂商对SQL标准的支持都可能不一样。比如MySQL在REPEATABLE READ 隔离级别上就已经
解决了幻读问题。

* 并发问题的解决方案：
    * 读取操作利用多版本控制并发控制(MVCC)，写操作进行加锁。
        普通的的SELECT语句在READ COMMITED和REPEATABLE READ隔离级别下会使用到MVCC读取记录
            1. 在READ COMMITTED隔离级别下，一个事务在执行的过程中每次执行SELECT操作时都会生成一个ReadView,ReadView的存在本身就保
               证了事务不可以读取到未提交的事务所作的更改
            2. 在REPEATABLE READ隔离级别下，一个事务的执行过程中只有第一次执行SELECT 操作才会生成ReadView,之后的SELECT操作都会复用
               这个ReadView，这样就可以避免了不可复用和幻读的问题。
    * 读，写操作都采用枷锁的方式
   
* 小结对比发现：
     * 采用MVCC 方式的话， 读-写操作彼此并不冲突， 性能更高。
     *  采用加锁方式的话， 读-写操作彼此需要排队执行，影响性能。
     
一般情况下我们当然愿意采用MVCC 来解决读-写操作并发执行的问题，但是业务在某些特殊情况
下，要求必须采用加锁的方式执行。下面就讲解下MySQL中不同类别的锁。            


## 锁的分类

![锁的分类](./files\数据库锁-2.png)

### 从数据操作的类型划分：读锁、写锁
* 读锁:也称为共享锁，英文用S表示，针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，互相阻塞的。
* 写锁:也称为排他锁，英文用X表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样就能够确保在给定的时间里，只有一个事务能够执行写入，
并且防止其他应用读取正在写入的同一资源.

注意:对于InnoDB引擎来说，读锁和写锁可以加在表上，也可以加在行上。

例子：
![读锁和读锁时可以共享的](./files\数据库锁-3.PNG)
![读锁和读锁时是互斥的](./files\数据库锁-4.PNG)

### 从数据操作的粒度划分：表级锁、页级锁、行锁
#### 表锁
1. 表级别的S锁，X锁
在对某个表执行SELECT、INSERT、UPDATE、DELETE语句时，InnoDB存储引擎是不会为这个表添加表级别的S锁或者X锁。在多某个表执行一些注入ALTER TABLE
DROP TABLE这里的DDL语句时，其他事务对这个表并发执行诸如SELECT、INSERT、UPDATE的语句会发生阻塞。同理，某个事务中对某个表执行SELECT、
INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行DDL语句也会发生阻塞。这个过程其实时通过server层使用一种称之为**元数据**(英文名：
Metadata Locks,简称MDL)结构来实现的。

一般情况下，不会使用InnoDB存储引擎提高的表级别的S锁和X锁。指挥在一些特殊情况下，比方说奔溃恢复过程中用到。比如，在系统变量autocommit=0,
innodb_table_locks=1时，手动获取InnoDB存储引擎提高的表t的S锁或者X锁可以这么写
    * LOCK TABLES t READ:InnoDB存储引擎会对表t加表级别的S锁。

    * LOCK TABLES t WRITE:InnoDB存储引擎会对表t加表级别的X锁。

不过要尽量避免使用InnoDB存储引擎的表上使用LOCK TABLES这样的手动锁表语句。它们并不会提供数目额外的保护，只是会降低并发能力而已。InnoDB
厉害指出还是实现更细粒度的行锁，关于InnoDB表级别的S锁和X锁了解下即可。

MySQL的表级别锁有两种模式:(MyISAM表进行操作)
    * 表共享读锁(Table Read Lock)
    * 表独占写锁(Table Write Lock)

|锁类型|自己可读|自己可写|自己可操作其他表|他人可读|他人可写|
| ---- | ---- | ---- | ---- | ---- | ----|
|读锁|是|否|否|否|是|否,等|
|写锁|是|是|否|否|否,等|否,等|


#### 意向锁
InnoDB支持多粒度锁(multiple granularity locking),它允许行级锁于表级锁共存，而意向锁就是其中的一种表锁。
    1. 意向锁的存在是为了协调行锁和表锁的关系，支持多粒度(表锁于行锁)的锁并存。
    2. 意向锁是一种不予行级锁冲突的表级送，这一点非常重要。
    3. 表明某个事务正在某些行持有了锁或该事务准备去持有锁。

意向锁分为两种：
    * 意向共享锁(Intenetion shared lock ,IS):事务有意想表中的某些行加共享锁(S锁)
        SELECT column FROM tablename...LOCK IN SHARE MODE;  -- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。
    * 意向排他锁(intention exclusive lock,IX):事务有意向对表中的某些行加排他锁(X锁)
        SELECT column FROM tablename...FROM UPDATE;-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。
        
1. 意向锁要解决的问题
假如现在有两个事务T1和T2，其中T2试图在该表级别上应用共享或者排它锁，如果没有意向锁存在，那么T2就需要去检查各个页或者行是否存在锁；如果存
在意向锁，那么此时就会受到由T1控制的表级别的意向锁的阻塞。T2在锁定该表前不必检查各个页或者行锁，而只需要检查表上的意向锁。简单的说就是给更
大一级别的空间示意里面是否已经上过锁。

在数据表的场景中，如果我们给某一行数据加上了排它锁，数据库会自动给更大以及的空间，比如数据页或数据表加上意向锁，高速其他人这个数据页或者数
据表已经有人上过排他锁了，这样当其他人想要获取数据表的排它锁的时候，只需要了解是否有人已经获取了这个数据表的意向排他锁即可。
    1. 如果事务想要获得数据表中某些记录的共享锁，就需要在数据表上添加意向共享锁
    2. 如果事务想要获得数据表中某些记录的排它锁，就需要在数据表上添加意向排他锁。

||意向共享锁(IS)|意向排它锁|
| ---- | ---- | ----|
|意向共享锁|兼容|兼容|
|意向排它锁一|兼容|兼容|
即意向锁之间是互相兼容的，虽然意向锁和自家兄弟互相兼容，但是他会于普通的排他锁/共享锁互斥


||意向共享锁(IS)|意向排它锁(IX)|
| ---- | ---- | ---- |
|共享锁(S)|兼容|互斥|
|排它锁(X)|互斥|互斥|

#### 自增锁(AUTO-INC锁)
 
#### 元数据锁（MDL锁）
MySQL5.5引入了meta data lock，简称MDL锁，属于表锁范畴。MDL 的作用是，保证读写的正确性。比
如，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，增加了一
列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。
因此，当对一个表做增删改查操作的时候，加 MDL读锁；当要对表做结构变更操作的时候，加 MDL 写
锁。

例子：
如果首先加了读锁，接着加写锁，最后加读锁会导致最后的读锁页会被阻塞主。
![MDL读和MDL读不阻塞，但是中间如果加了MDL写会阻塞](./files\数据库锁-5.PNG)    


### 行锁
 