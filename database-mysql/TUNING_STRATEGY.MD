[上一章(数据库设计原则)](./DESIGN_PRINCIPLES_SPECIFICATIONS_DATABASE.MD)
# 数据库调优的措施
* 调优的目标
    * 尽可能的节省系统资源，以便系统可以提高更大负荷的服务(吞吐量更大)
    * 合理的结构设计和参数调整，以提高用户操作响应的速度(响应速度更快)
    * 减少系统的瓶颈，提高MySQL数据库整体的性能
## 定位问题
   随着用户的增加，应用沉痼的复杂度的提升，我们很难用"更快"去定义数据库调优的目标，因为用户在不同的时间段访问服务器遇到的瓶颈不同，比
如双十一促销带来的大规模的并发访问;还有用户在进行不同业务操作的时候，数据库的事务处理和SQL查询都会有所不同。因此我们还需要更加精确的定位
去确定调优的目标。

* 如何确定调优的目标:
    * 用户的反馈(主要)
        用户是我们的服务对象，因此他们的反馈是最直接的。虽然他们不会直接提出技术建议，但是有些问题往往是用户第一时间发现的。我们需要重视用户
        的反馈，找到和数据相关的问题。
    * 日志分析(主要)
        我们可以通过查看数据库日志和操作系统日志等方式找出异常情况，通过他们来定位遇到的问题。
    *　服务器资源的使用监控
        通过监控服务器的CPU、内存、I/O等使用情况，可以实时了解服务器的性能使用，与历史情况进行对比。
    * 数据库内部情况监控
        在书库监控中，活动会话(Active Session)监控是一个重要的指标，通过它，我们可以清楚的了解数据库的当前是否处于非常繁忙的状态，是否存在SQL堆积等
    * 其他
        除了活动监控以外，我们也可以对事务，锁等待等进行监控，这些都可以帮助我们对数据库的运行状态有更加全面的认识。
                         
## 调优的维度和步骤
我们需要调优的对象是整个数据库管理系统，它不仅包括SQL查询，还包括数据库的部署配置、架构等。从这个角度来书，我们思考的维度就不仅仅局限在
SQL优化上了。通过如下的步骤我们进行梳理：
    1. 选择合适DBMS
        如果对事务性处理以及安全性要求高的话，可以选择商业的数据库产品。这些数据库在事务处理和查询性能上都是比较强悍的，比如oracle,
        SQL Server,那么单表存储上亿条数据都是没有问题的。如果数据表设计的很好，及时不采用分库分表的处理方式，查询的效率也是不错的。
        除此之外，我们采用开源的MySQL进行存储，它有很多存储引擎可以选择，如果进行事务处理的话可以选择使用InnoDB,非事务处理可以选择MyISAM
        NoSQL数据库包括键值数据库、文档数据库、搜索引擎、列式存储和如下数据库。这些数据库的优缺点和使用场景各不相同，比如劣势存储数据库
        可以大幅度降低系统的I/O，适合分布式文件细他，但是如果数据需要频繁的增删改，那么列式存储就不太适用了。
        
        
2. 优化表设计   
    选择合适的DBMS之后，我们需要进行表设计了。而数据表的设计方式也直接影响了后续的SQL查询语句。RDBMS中，每个对象都可以定义为一张表，表
    与表之间关系代表了对象之间的关系。如果用的式MySQL,我们还可以根据不同的表的使用需求，选择不太的存储引擎。除此之外，还有一些有的原则
    可以参考:
        1. 表结构要尽量遵循三范式的原则。这样可以让数据结构更加清晰规范，减少冗余字段，同时也减少了在更新，插入和删除数据时等异常情况。
        2. 如果查询应用比价哦多，尤其时需要多表关联查询的时候，可以采用反范式的进行优化。反范式采用空间换时间的方式，通过增加冗余的字段提高查询的效率
        3. 表字段的数据类型选择，关系到查询效率的高低以及存储空间的大小。一般来说，如果字段可以采用数值型就不要采用自读类型；字符长度要尽可能
        的设计的简短一些。针对字符类型来说，当确定字符长度固定时，就采用CHAR类型；当长度不固定时，通常采用VARCHAR类型.
        
        
3. 优化逻辑查询
当我们建立好数据表之后，我们就可以对数据表进行增删该操作了。这时我们首先需要考虑的时逻辑查询优化。SQL查询优化，可以分为**逻辑查询优化**和
**物理查询优化**。逻辑查询优化就是通过改变SQL语句的内容让SQL执行效率更高效，采用的方式时对SQL语句进行等价交换，对查询进行重写。
SQL查询重写包括了查询优化，等价为此重写，视图重写，条件简化，连接消除和嵌套连接消除等。
            
4.优化物理查询

物理查询优化是在确定了逻辑查询优化之后，采用物理优化技术（比如索引等），通过计算代价模型对
各种可能的访问路径进行估算，从而找到执行方式中代价最小的作为执行计划。在这个部分中，我们需
要掌握的重点是对索引的创建和使用。        

5. 使用 Redis 或 Memcached 作为缓存       
除了可以对 SQL 本身进行优化以外，我们还可以请外援提升查询的效率。
因为数据都是存放到数据库中，我们需要从数据库层中取出数据放到内存中进行业务逻辑的操作，当用
户量增大的时候，如果频繁地进行数据查询，会消耗数据库的很多资源。如果我们将常用的数据直接放
到内存中，就会大幅提升查询的效率。
键值存储数据库可以帮我们解决这个问题。
常用的键值存储数据库有 Redis 和 Memcached，它们都可以将数据存放到内存中。     
   
6.库级优化     
库级优化时站在数据库的维度上进行的优化策略，比如控制一个库中的数据表数量。另外，单一的数据库总会遇到各种限制，不如取长补短，利用"外援"的方式。
通过主从架构优化我们的读写策略，通过对数据库进行垂直或者水平切分，突破单以数据库或者数据表的访问限制，提升查询的性能。
   
  1.读写分离      
    如果读和写的业务量很大，并且它们都在同一个数据库服务器中进行操作，那么数据库的性能就会出现性能瓶颈，这是为了提升系统的性能，优化用户体验，
    我们可以采取读写分离的方式江都主数据库的负载，比如主数据库(master)完成写操作，从数据库(slave)完成读操作。   
    ![一主一从](./files\数据库调优策略-1.png)    
    ![双主双从](./files\数据库调优策略-2.png)    
        
        
   2.数据分片     
   对数据库分库分表。当数据量达到千万级别以上，有时候我们需要把一个数据库切分成多份，放到不同的数据库服务器上，减少对单以数据库服务器的访问压力
   如果你使用的时MySQL,就可以使用MySQL自带的分区表功能，当然可以考虑自己做垂直拆分(分库)，水平拆分(分表)，垂直+水平拆分(分库分表)。
   ![](./files\数据库调优策略-3.png)
   ![](./files\数据库调优策略-4.png)
        
## 优化MySQL服务器
### 优化服务器硬件
服务器的硬件性能直接决定着MySQL数据库的性能。硬件的性能瓶颈直接决定了MySQL数据库的运行速度和效率。针对性能瓶颈提高硬件配置，可以提高 MySQL
数据库查询，更新的速度
1. 配置较大的内存
2. 配置高速磁盘系统
3. 合理分布磁盘I/O
4. 配置多处理器
### 优化MySQL的参数

* innodb_buffer_pool_size:这个参数时Mysql数据库的最重要的参数之一，标识InnoDB类型的表和索引的最大缓存。它不仅仅缓存索引数据，还会缓存
表的疏忽。这个值越大，查询的速度就会越快，但是这个值太大会影响操作系统的性能。
* key_buffer_size:表示索引缓冲区的大小。索引缓冲区时所有线程共享的。增加索引缓冲区可以得到更好处理的索引(对所有读和多重写)。当然，这个
值不是越大越好，它的大小取决于内存的大小，如果这个值太大，就会导致操作系统频繁的换页，也就会降低系统性能。针对内存在4GB左右的服务器该参数可
设置为256M或384M.
* table_open_cache:表示同时打开的表的个数。这个值越大，能够同时打开的比爱的个数就越多，物理内粗越大没设置就越大。默认时2402,调到512-1024
最佳。这个值不是越大越好，因为同时打开的表太多会影响操作系统的性能。
![table_open_cache打开表的个数](./files\数据库调优策略-5.PNG)

* query_cache_size:表示查询缓冲区的大小。可以通过在MySQL控制台观察，如果Query_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况，
就要怎该Query_cache_size
![query_cache_size查询缓冲区的大小](./files\数据库调优策略-6.PNG)

* query_cache_type的值时0时，所有的查询都不适应查询缓存去。但是query_cache_type=0并不会导致MySQL释放query_cache_size所配置的缓存区内存。
    * 当query_cache_type=1时，所有的查询都将使用查询缓存区，除非在拆线呢的语句中指定SQL_NO_CACHE,如SELECT SQL_NO_CACHE * FROM table_name;
    * 当query_cache_type=2时，只有在查询语句中使用SQL_CACHE关键字，查询才会使用查询缓存区。使用查询缓存区可以提高查询的速度，这种方
    式只适用于修改操作少且经常执行相同查询操作的情况。
* sort_buffer_size:表示每个需要排序的线程分配的缓冲区的大小。增加这个参数的值可以提高ORDER BY 或者GROUP BY操作的速度。
![sort_buffer_size排序缓存大小](./files\数据库调优策略-7.PNG)
* join_buffer_size:表示联合查询操作所能使用的缓冲区大小，和sort_buffer_size一样，该参数对于的分配内存也时每个连接独享的。
![join_buffer_size](./files\数据库调优策略-9.PNG)
* read_buffer_size:表示每个线程连续扫描时为扫描的每个表分配的缓冲区的大小(字节)。当线程从表中连续读取记录时需要用到这个缓冲区。SET SESSION
read_buffer_size=n可以临时设置该参数的值
![join_buffer_size](./files\数据库调优策略-8.PNG)
* innodb_flush_log_at_trx_commit:表示合适将缓冲区的数据写入日志文件，并且将日志文件写入磁盘中。该参数对于innodb存储引擎非常重要。该参数有3个值
分别为0、1和2.该参数的默认值时1
    * 值为0时，表示每秒1次的频率将数据写入日志文件并将日志文件写入磁盘。每个事务的commit并不会触发前面的的任何操作。该模式速度最快，但是不安全，
    mysqlld紧凑的奔溃会导致上一秒中的所有事务数据的丢失。
    * 值为1时，表示每次提交事务时，将数据写入日志文件并将日志文件吸入磁盘进行同步。该模式最安全的，但是也是最慢的一种方式。因为每次事务提交
    或事务外的指令都需要把日志写入磁盘。
    * 值为2时，表示每次提交事务时将数据写入日志文件，每隔1秒将日志文件写入磁盘。该模式速度较快，也是比0安全，只有在操作系统奔溃或者系统断电
    的情况下，上一秒钟所有的事务数据可能丢失。
![innodb_flush_log_at_trx_commit](./files\数据库调优策略-10.PNG)          
        
* innodb_log_buffer_size:这是innodb存储引擎的事务日志所使用的缓冲区。为了提高性能，也时将信息写入Innodb Log Buffer中，当满足
innodb_flush_log_at_trx_commit参数所设置的相应条件(或者日志缓冲区写满了)之后，才会将日志写到文件(或者同步到磁盘)中.
![innodb_log_buffer_size](./files\数据库调优策略-11.PNG)
* max_connections:表示允许连接到MySQL书库的最大数量，默认值时151。如果状态变量connection_errors_max_connections不为0，并且一直增长
则说明不断有请求因数据库连接数已经达到最大值而失败，这时可以考虑增加max_connections的值。在Linux平台下，性能好的服务器，支持500-1000个
连接不是难事，，需要根据服务器性能进行评估设定。这个连接数不是越大 越好，因为这些连接会浪费内存的资源。过多的连接可能会导致MySQL服务器僵死。        
![max_connections](./files\数据库调优策略-12.PNG)

* back_log:用于控制MySQL监听TCP端口时设置的挤压请求栈大小。如果MySQL的链接数达到了max_connections时，新来的请求将会被存在堆栈中，一等待某
一连接释放资源，该堆栈的数量即时back_log，如果等待连接的数量超过了back_log，将不被授予连接资源，将会报错。5.6.6版本之前默认值为50，之后的
版本默认为50+(max_connections/5)，对于Linux系统推荐设置为小于512的整数，但最大不超过900.
如果需要数据库在较短的时间内处理大量连接请求， 可以考虑适当增大back_log 的值。
![back_log](./files\数据库调优策略-13.PNG)       
        
* thread_cache_size:线程池缓存线程数量的大小，当客户端断开连接后将当前线程缓存起来当在接到新的连接请求时快速响应无需创建新的线程 。这
尤其对那些使用短连接的应用程序来说可以极大的提高创建连接的效率。那么为了提高性能可以增大该参数的值。默认为60，可以设置为120。        
![thread_cache_size](.files\数据库调优策略-14.PNG)        
当 Threads_cached 越来越少，但 Threads_connected 始终不降，且 Threads_created 持续升高，可
适当增加 thread_cache_size 的大小

* wait_timeout ：指定一个请求的最大连接时间，对于4GB左右内存的服务器可以设置为5-10。

* interactive_timeout ：表示服务器在关闭连接前等待行动的秒数。        
        
一份my.cnf配置
```text
[mysqld]
port = 3306 
serverid = 1 
socket = /tmp/mysql.sock skip-locking #避免MySQL的外部锁定，减少出错几率增强稳定性。 
skip-name-resolve #禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。但需要注意，如果开启该选项，则所有远程主机连接授权
都要使用IP地址方式，否则MySQL将无法正常处理连接请求！ back_log = 384
key_buffer_size = 256M 
max_allowed_packet = 4M 
thread_stack = 256K
table_cache = 128K 
sort_buffer_size = 6M 
read_buffer_size = 4M
read_rnd_buffer_size=16M 
join_buffer_size = 8M 
myisam_sort_buffer_size =64M 
table_cache = 512 
thread_cache_size = 64 
query_cache_size = 64M
tmp_table_size = 256M 
max_connections = 768 
max_connect_errors = 10000000
wait_timeout = 10 
thread_concurrency = 8 #该参数取值为服务器逻辑CPU数量*2，在本
例中，服务器有2颗物理CPU，而每颗物理CPU又支持H.T超线程，所以实际取值为4*2=8 skipnetworking
#开启该选项可以彻底关闭MySQL的TCP/IP连接方式，如果WEB服务器是以远程连接
的方式访问MySQL数据库服务器则不要开启该选项！否则将无法正常连接！ table_cache=1024
innodb_additional_mem_pool_size=4M #默认为2M innodb_flush_log_at_trx_commit=1
innodb_log_buffer_size=2M #默认为1M innodb_thread_concurrency=8 #你的服务器CPU
有几个就设置为几。建议用默认一般为8 tmp_table_size=64M #默认为16M，调到64-256最挂
thread_cache_size=120 query_cache_size=32M
```        
        
##  优化数据库结构
